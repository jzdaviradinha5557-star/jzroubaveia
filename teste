-- ========================================
-- SCRIPT COMPLETO COM NOCLIP E FLY
-- ========================================

-- Removedor de AntiCheat
pcall(function()
    local pathsToDelete = {
        "ReplicatedStorage.Remotes.ExploitBan",
        "ReplicatedStorage.KillCam"
    }
    
    for _, path in ipairs(pathsToDelete) do
        local parts = string.split(path, ".")
        local current = game:GetService(parts[1])
        
        for i = 2, #parts - 1 do
            if current then
                current = current:FindFirstChild(parts[i])
            end
        end
        
        if current then
            local target = current:FindFirstChild(parts[#parts])
            if target then
                pcall(function()
                    target:Destroy()
                end)
            end
        end
    end
end)

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

if not Player then return end

-- Variáveis
local aimPartName = "Cabesa"
local fovRadius = 80
local fovColor = Color3.fromRGB(255, 255, 255)
local fovThickness = 1
local smoothness = 15
local aimbotEnabled = false
local aimbotConnection = nil
local fovUpdateConnection = nil
local fovVisible = false

local triggerbotEnabled = false
local headExpansionConnection = nil
local originalHeadSizes = {}

local loopBringEnabled = false
local loopBringConnection = nil
local loopBringRadius = 600

local speedWalkEnabled = false
local speedWalkValue = 16
local originalWalkSpeed = 16

local noclipEnabled = false
local noclipConnection = nil

local flyEnabled = false
local flySpeed = 50
local flyConnection = nil
local flyControl = {W = false, A = false, S = false, D = false, Space = false, LeftShift = false}

local chamsEnabled = false
local boxEspEnabled = false
local linesEnabled = false
local nameEnabled = false
local distanceEnabled = false
local espRadius = 600
local espObjects = {}
local espPlayerAddedConn = nil
local espPlayerRemovingConn = nil

-- UI Principal
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "LocalPlayerMenu"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = PlayerGui

local MainContainer = Instance.new("Frame")
MainContainer.Name = "MainContainer"
MainContainer.Size = UDim2.new(0, 360, 0, 260)
MainContainer.Position = UDim2.new(0.5, -180, 0.5, -130)
MainContainer.BackgroundColor3 = Color3.fromRGB(29, 29, 29)
MainContainer.BorderSizePixel = 0
MainContainer.Parent = ScreenGui

local MainCorner = Instance.new("UICorner")
MainCorner.CornerRadius = UDim.new(0, 12)
MainCorner.Parent = MainContainer

local MainGradient = Instance.new("UIGradient")
MainGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(26, 26, 26))
}
MainGradient.Rotation = 90
MainGradient.Parent = MainContainer

local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 12, 0, 12)
MinimizeButton.Position = UDim2.new(1, -20, 0, 10)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 165, 0)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.Text = ""
MinimizeButton.ZIndex = 2
MinimizeButton.Parent = MainContainer

local MinimizeCorner = Instance.new("UICorner")
MinimizeCorner.CornerRadius = UDim.new(1, 0)
MinimizeCorner.Parent = MinimizeButton

local MinimizedDot = Instance.new("TextButton")
MinimizedDot.Name = "MinimizedDot"
MinimizedDot.Size = UDim2.new(0, 20, 0, 20)
MinimizedDot.Position = UDim2.new(0, 20, 0, 20)
MinimizedDot.BackgroundColor3 = Color3.fromRGB(255, 165, 0)
MinimizedDot.BorderSizePixel = 0
MinimizedDot.Text = ""
MinimizedDot.Visible = false
MinimizedDot.ZIndex = 3
MinimizedDot.Parent = ScreenGui

local DotCorner = Instance.new("UICorner")
DotCorner.CornerRadius = UDim.new(1, 0)
DotCorner.Parent = MinimizedDot

local Sidebar = Instance.new("Frame")
Sidebar.Name = "Sidebar"
Sidebar.Size = UDim2.new(0, 90, 1, 0)
Sidebar.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
Sidebar.BorderSizePixel = 0
Sidebar.Parent = MainContainer

local SidebarCorner = Instance.new("UICorner")
SidebarCorner.CornerRadius = UDim.new(0, 12)
SidebarCorner.Parent = Sidebar

local Border = Instance.new("Frame")
Border.Size = UDim2.new(0, 2, 1, 0)
Border.Position = UDim2.new(1, 0, 0, 0)
Border.BackgroundColor3 = Color3.fromRGB(255, 0, 255)
Border.BorderSizePixel = 0
Border.Parent = Sidebar

local Logo = Instance.new("TextLabel")
Logo.Name = "Logo"
Logo.Size = UDim2.new(0, 50, 0, 50)
Logo.Position = UDim2.new(0.5, -25, 0, 15)
Logo.BackgroundColor3 = Color3.fromRGB(255, 0, 255)
Logo.BorderSizePixel = 0
Logo.Text = "R"
Logo.TextColor3 = Color3.fromRGB(255, 255, 255)
Logo.TextSize = 30
Logo.Font = Enum.Font.GothamBold
Logo.Parent = Sidebar

local LogoCorner = Instance.new("UICorner")
LogoCorner.CornerRadius = UDim.new(0, 12)
LogoCorner.Parent = Logo

local LogoGradient = Instance.new("UIGradient")
LogoGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 170))
}
LogoGradient.Rotation = 135
LogoGradient.Parent = Logo

local ContentArea = Instance.new("Frame")
ContentArea.Name = "ContentArea"
ContentArea.Size = UDim2.new(1, -90, 1, 0)
ContentArea.Position = UDim2.new(0, 90, 0, 0)
ContentArea.BackgroundTransparency = 1
ContentArea.Parent = MainContainer

local TabsContainer = Instance.new("Frame")
TabsContainer.Name = "TabsContainer"
TabsContainer.Size = UDim2.new(1, -20, 0, 30)
TabsContainer.Position = UDim2.new(0, 10, 0, 10)
TabsContainer.BackgroundTransparency = 1
TabsContainer.Parent = ContentArea

local TabBorder = Instance.new("Frame")
TabBorder.Size = UDim2.new(1, 0, 0, 1)
TabBorder.Position = UDim2.new(0, 0, 1, -1)
TabBorder.BackgroundColor3 = Color3.fromRGB(51, 51, 51)
TabBorder.BorderSizePixel = 0
TabBorder.Parent = TabsContainer

-- FOV Circle
if PlayerGui:FindFirstChild("FOVCircle") then
    PlayerGui.FOVCircle:Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FOVCircle"
screenGui.Parent = PlayerGui
screenGui.ResetOnSpawn = false

local fovCircle = Instance.new("Frame")
fovCircle.Name = "FOV"
fovCircle.Parent = screenGui
fovCircle.AnchorPoint = Vector2.new(0.5, 0.5)
fovCircle.Position = UDim2.new(0.5, 0, 0.5, -10)
fovCircle.Size = UDim2.new(0, fovRadius * 2, 0, fovRadius * 2)
fovCircle.BackgroundTransparency = 1
fovCircle.BorderSizePixel = 0
fovCircle.Visible = false

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = fovCircle

local stroke = Instance.new("UIStroke")
stroke.Parent = fovCircle
stroke.Thickness = fovThickness
stroke.Color = fovColor
stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
stroke.LineJoinMode = Enum.LineJoinMode.Round

-- Funções Aimbot
local function canSeeTarget(targetPart)
    local origin = Workspace.CurrentCamera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {Player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    if raycastResult then
        return raycastResult.Instance:IsDescendantOf(targetPart.Parent)
    else
        return true
    end
end

local function getClosestTarget()
    local closestPart, closestDistance = nil, math.huge
    local camera = Workspace.CurrentCamera
    local screenCenter = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Player and player.Character and player.Character:FindFirstChild(aimPartName) then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local part = player.Character[aimPartName]
                local pos, onScreen = camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(pos.X, pos.Y) - screenCenter).Magnitude
                    if dist <= fovRadius and canSeeTarget(part) then
                        if dist < closestDistance then
                            closestDistance = dist
                            closestPart = part
                        end
                    end
                end
            end
        end
    end
    return closestPart
end

local function startAimbot()
    if aimbotConnection then return end
    
    fovUpdateConnection = RunService.RenderStepped:Connect(function()
        if fovCircle and fovCircle.Parent then
            fovCircle.Position = UDim2.new(0.5, 0, 0.5, -25)
            fovCircle.Size = UDim2.new(0, fovRadius * 2, 0, fovRadius * 2)
        end
    end)
    
    aimbotConnection = RunService.RenderStepped:Connect(function()
        if not aimbotEnabled then return end
        
        local targetPart = getClosestTarget()
        if targetPart and targetPart.Parent then
            local camera = Workspace.CurrentCamera
            local targetCFrame = CFrame.new(camera.CFrame.Position, targetPart.Position)
            
            if smoothness > 1 then
                local smoothFactor = 1 / smoothness
                camera.CFrame = camera.CFrame:Lerp(targetCFrame, smoothFactor)
            else
                camera.CFrame = targetCFrame
            end
        end
    end)
end

local function stopAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
        aimbotConnection = nil
    end
    if fovUpdateConnection then
        fovUpdateConnection:Disconnect()
        fovUpdateConnection = nil
    end
    fovCircle.Visible = false
    fovVisible = false
end

-- Funções Triggerbot
function getplrsname()
    for i,v in pairs(game:GetChildren()) do
        if v.ClassName == "Players" then
            return v.Name
        end
    end
end

local function expandHead(head)
    if not head then return end
    
    if not originalHeadSizes[head] then
        originalHeadSizes[head] = head.Size
    end
    
    head.CanCollide = false
    head.Transparency = 1
    head.Material = Enum.Material.Neon
    head.Size = Vector3.new(4.6, 4.6, 4.6)
end

local function restoreHead(head)
    if not head then return end
    
    if originalHeadSizes[head] then
        head.Size = originalHeadSizes[head]
        head.Transparency = 0
        originalHeadSizes[head] = nil
    end
end

local function startTriggerbot()
    if headExpansionConnection then return end
    
    local players = getplrsname()
    if not players then return end
    
    local starterPlayer = game:GetService("StarterPlayer")
    if starterPlayer.StarterCharacter:FindFirstChild("Cabesa") then
        expandHead(starterPlayer.StarterCharacter.Cabesa)
    end
    
    headExpansionConnection = RunService.Heartbeat:Connect(function()
        if not triggerbotEnabled then return end
        
        for _, v in pairs(game[players]:GetPlayers()) do
            if v ~= Player and v.Character then
                local head = v.Character:FindFirstChild("Cabesa") or v.Character:FindFirstChild("Head")
                if head then
                    expandHead(head)
                end
            end
        end
    end)
end

local function stopTriggerbot()
    if headExpansionConnection then
        headExpansionConnection:Disconnect()
        headExpansionConnection = nil
    end
    
    local players = getplrsname()
    if players then
        for _, v in pairs(game[players]:GetPlayers()) do
            if v.Character then
                local head = v.Character:FindFirstChild("Cabesa") or v.Character:FindFirstChild("Head")
                if head then
                    restoreHead(head)
                end
            end
        end
    end
    
    local starterPlayer = game:GetService("StarterPlayer")
    if starterPlayer.StarterCharacter:FindFirstChild("Cabesa") then
        restoreHead(starterPlayer.StarterCharacter.Cabesa)
    end
end

-- Funções LoopBring
local function startLoopBring()
    if loopBringConnection then return end
    
    loopBringConnection = RunService.Heartbeat:Connect(function()
        if not loopBringEnabled then return end
        
        local myChar = Player.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= Player and player.Character then
                local theirRoot = player.Character:FindFirstChild("HumanoidRootPart")
                if theirRoot then
                    local distance = (theirRoot.Position - myRoot.Position).Magnitude
                    
                    if distance <= loopBringRadius then
                        pcall(function()
                            theirRoot.CFrame = myRoot.CFrame * CFrame.new(0, 0, -8)
                        end)
                    end
                end
            end
        end
    end)
end

local function stopLoopBring()
    if loopBringConnection then
        loopBringConnection:Disconnect()
        loopBringConnection = nil
    end
end

-- Funções SpeedWalk
local function startSpeedWalk()
    local myChar = Player.Character
    local humanoid = myChar and myChar:FindFirstChild("Humanoid")
    
    if humanoid then
        originalWalkSpeed = humanoid.WalkSpeed
        humanoid.WalkSpeed = speedWalkValue
    end
end

local function stopSpeedWalk()
    local myChar = Player.Character
    local humanoid = myChar and myChar:FindFirstChild("Humanoid")
    
    if humanoid then
        humanoid.WalkSpeed = originalWalkSpeed
    end
end

local function updateSpeedWalk()
    if speedWalkEnabled then
        local myChar = Player.Character
        local humanoid = myChar and myChar:FindFirstChild("Humanoid")
        
        if humanoid then
            humanoid.WalkSpeed = speedWalkValue
        end
    end
end

-- Loop para manter velocidade
RunService.Heartbeat:Connect(function()
    if speedWalkEnabled then
        local myChar = Player.Character
        local humanoid = myChar and myChar:FindFirstChild("Humanoid")
        
        if humanoid and humanoid.WalkSpeed ~= speedWalkValue then
            humanoid.WalkSpeed = speedWalkValue
        end
    end
end)

-- Funções NoClip
local function startNoclip()
    if noclipConnection then return end
    
    noclipConnection = RunService.Stepped:Connect(function()
        if not noclipEnabled then return end
        
        local myChar = Player.Character
        if not myChar then return end
        
        for _, part in pairs(myChar:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

local function stopNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    
    local myChar = Player.Character
    if myChar then
        for _, part in pairs(myChar:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Funções Fly
local function startFly()
    if flyConnection then return end
    
    local myChar = Player.Character
    local humanoidRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not humanoidRoot then return end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Name = "FlyVelocity"
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = humanoidRoot
    
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.Name = "FlyGyro"
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 9e9
    bodyGyro.CFrame = humanoidRoot.CFrame
    bodyGyro.Parent = humanoidRoot
    
    flyConnection = RunService.Heartbeat:Connect(function()
        if not flyEnabled then return end
        
        local myChar = Player.Character
        local humanoidRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local camera = Workspace.CurrentCamera
        
        if not humanoidRoot or not bodyVelocity or not bodyGyro then
            stopFly()
            return
        end
        
        local direction = Vector3.new(0, 0, 0)
        
        if flyControl.W then
            direction = direction + (camera.CFrame.LookVector * flySpeed)
        end
        if flyControl.S then
            direction = direction - (camera.CFrame.LookVector * flySpeed)
        end
        if flyControl.A then
            direction = direction - (camera.CFrame.RightVector * flySpeed)
        end
        if flyControl.D then
            direction = direction + (camera.CFrame.RightVector * flySpeed)
        end
        if flyControl.Space then
            direction = direction + Vector3.new(0, flySpeed, 0)
        end
        if flyControl.LeftShift then
            direction = direction - Vector3.new(0, flySpeed, 0)
        end
        
        bodyVelocity.Velocity = direction
        bodyGyro.CFrame = camera.CFrame
    end)
end

local function stopFly()
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
    
    local myChar = Player.Character
    local humanoidRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    
    if humanoidRoot then
        local flyVelocity = humanoidRoot:FindFirstChild("FlyVelocity")
        local flyGyro = humanoidRoot:FindFirstChild("FlyGyro")
        
        if flyVelocity then flyVelocity:Destroy() end
        if flyGyro then flyGyro:Destroy() end
    end
    
    for key, _ in pairs(flyControl) do
        flyControl[key] = false
    end
end

-- Input para Fly
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if flyEnabled then
        if input.KeyCode == Enum.KeyCode.W then
            flyControl.W = true
        elseif input.KeyCode == Enum.KeyCode.A then
            flyControl.A = true
        elseif input.KeyCode == Enum.KeyCode.S then
            flyControl.S = true
        elseif input.KeyCode == Enum.KeyCode.D then
            flyControl.D = true
        elseif input.KeyCode == Enum.KeyCode.Space then
            flyControl.Space = true
        elseif input.KeyCode == Enum.KeyCode.LeftShift then
            flyControl.LeftShift = true
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if flyEnabled then
        if input.KeyCode == Enum.KeyCode.W then
            flyControl.W = false
        elseif input.KeyCode == Enum.KeyCode.A then
            flyControl.A = false
        elseif input.KeyCode == Enum.KeyCode.S then
            flyControl.S = false
        elseif input.KeyCode == Enum.KeyCode.D then
            flyControl.D = false
        elseif input.KeyCode == Enum.KeyCode.Space then
            flyControl.Space = false
        elseif input.KeyCode == Enum.KeyCode.LeftShift then
            flyControl.LeftShift = false
        end
    end
end)

-- Funções ESP
local function removeESPForPlayer(player)
    local objs = espObjects[player]
    if not objs then return end
    
    pcall(function()
        if objs.box then
            for _, line in pairs(objs.box) do
                if line and line.Remove then line:Remove() end
            end
        end
        if objs.tracer and objs.tracer.Remove then objs.tracer:Remove() end
        if objs.nameText and objs.nameText.Remove then objs.nameText:Remove() end
        if objs.distText and objs.distText.Remove then objs.distText:Remove() end
        
        if objs.highlight and objs.highlight.Parent then
            objs.highlight:Destroy()
        end
        
        if objs.conn and objs.conn.Disconnect then
            objs.conn:Disconnect()
        end
    end)
    
    espObjects[player] = nil
end

local function createESPForPlayer(player)
    if not player or player == Player or espObjects[player] then return end
    
    if not Drawing or type(Drawing.new) ~= "function" then
        return
    end

    local box = {
        Drawing.new("Line"),
        Drawing.new("Line"),
        Drawing.new("Line"),
        Drawing.new("Line")
    }
    
    for _, line in pairs(box) do
        line.Thickness = 2
        line.Color = Color3.fromRGB(255, 0, 255)
        line.Transparency = 1
        line.Visible = false
    end
    
    local tracer = Drawing.new("Line")
    tracer.Thickness = 2
    tracer.Color = Color3.fromRGB(255, 0, 255)
    tracer.Transparency = 1
    tracer.Visible = false
    
    local nameText = Drawing.new("Text")
    nameText.Size = 16
    nameText.Color = Color3.fromRGB(255, 255, 255)
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false
    
    local distText = Drawing.new("Text")
    distText.Size = 14
    distText.Color = Color3.fromRGB(200, 200, 200)
    distText.Center = true
    distText.Outline = true
    distText.Visible = false
    
    local highlight = nil
    
    local conn
    conn = RunService.RenderStepped:Connect(function()
        local char = player.Character
        if not char then
            for _, line in pairs(box) do line.Visible = false end
            tracer.Visible = false
            nameText.Visible = false
            distText.Visible = false
            if highlight then highlight.Enabled = false end
            return
        end

        local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("UpperTorso")
        local hum = char:FindFirstChild("Humanoid")
        local head = char:FindFirstChild("Head") or char:FindFirstChild("Cabesa")
        
        if not root or not hum or hum.Health <= 0 then
            for _, line in pairs(box) do line.Visible = false end
            tracer.Visible = false
            nameText.Visible = false
            distText.Visible = false
            if highlight then highlight.Enabled = false end
            return
        end

        local myChar = Player.Character
        local myRoot = myChar and (myChar:FindFirstChild("HumanoidRootPart") or myChar:FindFirstChild("UpperTorso"))
        if not myRoot then
            for _, line in pairs(box) do line.Visible = false end
            tracer.Visible = false
            nameText.Visible = false
            distText.Visible = false
            if highlight then highlight.Enabled = false end
            return
        end

        local distance = (root.Position - myRoot.Position).Magnitude
        
        if distance > espRadius then
            for _, line in pairs(box) do line.Visible = false end
            tracer.Visible = false
            nameText.Visible = false
            distText.Visible = false
            if highlight then highlight.Enabled = false end
            return
        end

        local camera = Workspace.CurrentCamera
        local rootPos, rootOnScreen = camera:WorldToViewportPoint(root.Position)
        
        if boxEspEnabled and rootOnScreen and rootPos.Z > 0 then
            local headPos = camera:WorldToViewportPoint((head and head.Position or root.Position) + Vector3.new(0, 0.5, 0))
            local legPos = camera:WorldToViewportPoint(root.Position - Vector3.new(0, 3, 0))
            
            local factor = 1 / rootPos.Z * 1000
            local width = math.clamp(factor, 20, 200)
            
            local topLeft = Vector2.new(rootPos.X - width/2, headPos.Y)
            local topRight = Vector2.new(rootPos.X + width/2, headPos.Y)
            local bottomLeft = Vector2.new(rootPos.X - width/2, legPos.Y)
            local bottomRight = Vector2.new(rootPos.X + width/2, legPos.Y)
            
            box[1].From = topLeft
            box[1].To = topRight
            box[2].From = bottomLeft
            box[2].To = bottomRight
            box[3].From = topLeft
            box[3].To = bottomLeft
            box[4].From = topRight
            box[4].To = bottomRight
            
            for _, line in pairs(box) do
                line.Visible = true
            end
        else
            for _, line in pairs(box) do
                line.Visible = false
            end
        end
        
        if linesEnabled and rootOnScreen and rootPos.Z > 0 then
            local screenSize = camera.ViewportSize
            tracer.From = Vector2.new(screenSize.X / 2, screenSize.Y)
            tracer.To = Vector2.new(rootPos.X, rootPos.Y)
            tracer.Visible = true
        else
            tracer.Visible = false
        end
        
        if nameEnabled and rootOnScreen and rootPos.Z > 0 then
            local headPos = camera:WorldToViewportPoint((head and head.Position or root.Position) + Vector3.new(0, 0.5, 0))
            nameText.Text = player.Name
            nameText.Position = Vector2.new(rootPos.X, headPos.Y - 20)
            nameText.Visible = true
        else
            nameText.Visible = false
        end
        
        if distanceEnabled and rootOnScreen and rootPos.Z > 0 then
            local legPos = camera:WorldToViewportPoint(root.Position - Vector3.new(0, 3, 0))
            distText.Text = string.format("%.1f studs", distance)
            distText.Position = Vector2.new(rootPos.X, legPos.Y + 5)
            distText.Visible = true
        else
            distText.Visible = false
        end
        
        if chamsEnabled then
            if not highlight then
                highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(255, 0, 255)
                highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.Parent = char
            end
            highlight.Enabled = true
        else
            if highlight then
                highlight.Enabled = false
            end
        end
    end)

    espObjects[player] = {
        box = box,
        tracer = tracer,
        nameText = nameText,
        distText = distText,
        highlight = highlight,
        conn = conn,
    }
end

local function startESP()
    if espPlayerAddedConn then return end
    
    if not Drawing or type(Drawing.new) ~= "function" then
        return
    end
    
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= Player then
            createESPForPlayer(p)
        end
    end
    
    espPlayerAddedConn = Players.PlayerAdded:Connect(function(player)
        if player ~= Player then
            createESPForPlayer(player)
        end
    end)
    
    espPlayerRemovingConn = Players.PlayerRemoving:Connect(function(player)
        removeESPForPlayer(player)
    end)
end

local function stopESP()
    for p, _ in pairs(espObjects) do
        removeESPForPlayer(p)
    end
    
    if espPlayerAddedConn then
        espPlayerAddedConn:Disconnect()
        espPlayerAddedConn = nil
    end
    if espPlayerRemovingConn then
        espPlayerRemovingConn:Disconnect()
        espPlayerRemovingConn = nil
    end
end

-- Funções UI
local function createToggle(parent, text, position, defaultValue, callback)
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Size = UDim2.new(1, 0, 0, 25)
    toggleFrame.Position = position
    toggleFrame.BackgroundTransparency = 1
    toggleFrame.Parent = parent

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.6, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text .. (defaultValue and ": On" or ": Off")
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 11
    label.Font = Enum.Font.GothamSemibold
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = toggleFrame

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, 40, 0, 18)
    toggleButton.Position = UDim2.new(1, -40, 0, 3)
    toggleButton.BackgroundColor3 = defaultValue and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(59, 59, 59)
    toggleButton.AutoButtonColor = false
    toggleButton.Text = ""
    toggleButton.Parent = toggleFrame

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 9)
    toggleCorner.Parent = toggleButton

    local toggleThumb = Instance.new("Frame")
    toggleThumb.Size = UDim2.new(0, 14, 0, 14)
    toggleThumb.Position = defaultValue and UDim2.new(0, 24, 0, 2) or UDim2.new(0, 2, 0, 2)
    toggleThumb.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    toggleThumb.Parent = toggleButton

    local thumbCorner = Instance.new("UICorner")
    thumbCorner.CornerRadius = UDim.new(0, 7)
    thumbCorner.Parent = toggleThumb

    local isToggled = defaultValue

    local function updateToggle()
        if isToggled then
            toggleThumb.Position = UDim2.new(0, 24, 0, 2)
            toggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 255)
            label.Text = text .. ": On"
        else
            toggleThumb.Position = UDim2.new(0, 2, 0, 2)
            toggleButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
            label.Text = text .. ": Off"
        end
    end

    toggleButton.MouseButton1Click:Connect(function()
        isToggled = not isToggled
        updateToggle()
        if callback then callback(isToggled) end
    end)

    return toggleFrame
end

local function createButtonControl(parent, text, position, minValue, maxValue, defaultValue, step, callback)
    local controlFrame = Instance.new("Frame")
    controlFrame.Size = UDim2.new(1, 0, 0, 28)
    controlFrame.Position = position
    controlFrame.BackgroundTransparency = 1
    controlFrame.Parent = parent

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.5, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text .. ": " .. defaultValue
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 11
    label.Font = Enum.Font.GothamSemibold
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = controlFrame

    local decreaseButton = Instance.new("TextButton")
    decreaseButton.Size = UDim2.new(0, 28, 0, 22)
    decreaseButton.Position = UDim2.new(1, -85, 0, 3)
    decreaseButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
    decreaseButton.Text = "-"
    decreaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    decreaseButton.TextSize = 16
    decreaseButton.Font = Enum.Font.GothamBold
    decreaseButton.Parent = controlFrame

    local decreaseCorner = Instance.new("UICorner")
    decreaseCorner.CornerRadius = UDim.new(0, 6)
    decreaseCorner.Parent = decreaseButton

    local valueDisplay = Instance.new("TextLabel")
    valueDisplay.Size = UDim2.new(0, 25, 0, 22)
    valueDisplay.Position = UDim2.new(1, -55, 0, 3)
    valueDisplay.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    valueDisplay.Text = tostring(defaultValue)
    valueDisplay.TextColor3 = Color3.fromRGB(255, 255, 255)
    valueDisplay.TextSize = 11
    valueDisplay.Font = Enum.Font.GothamBold
    valueDisplay.Parent = controlFrame

    local displayCorner = Instance.new("UICorner")
    displayCorner.CornerRadius = UDim.new(0, 6)
    displayCorner.Parent = valueDisplay

    local increaseButton = Instance.new("TextButton")
    increaseButton.Size = UDim2.new(0, 28, 0, 22)
    increaseButton.Position = UDim2.new(1, -28, 0, 3)
    increaseButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
    increaseButton.Text = "+"
    increaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    increaseButton.TextSize = 16
    increaseButton.Font = Enum.Font.GothamBold
    increaseButton.Parent = controlFrame

    local increaseCorner = Instance.new("UICorner")
    increaseCorner.CornerRadius = UDim.new(0, 6)
    increaseCorner.Parent = increaseButton

    local currentValue = defaultValue

    local function updateValue(newValue)
        currentValue = math.clamp(newValue, minValue, maxValue)
        valueDisplay.Text = tostring(currentValue)
        label.Text = text .. ": " .. currentValue
        if callback then callback(currentValue) end
    end

    decreaseButton.MouseButton1Click:Connect(function()
        updateValue(currentValue - step)
    end)

    increaseButton.MouseButton1Click:Connect(function()
        updateValue(currentValue + step)
    end)

    return controlFrame
end

-- Criar Seções
local AimSection = Instance.new("Frame")
AimSection.Name = "AimSection"
AimSection.Size = UDim2.new(1, -20, 1, -50)
AimSection.Position = UDim2.new(0, 10, 0, 45)
AimSection.BackgroundTransparency = 1
AimSection.Visible = true
AimSection.Parent = ContentArea

local EspSection = Instance.new("Frame")
EspSection.Name = "EspSection"
EspSection.Size = UDim2.new(1, -20, 1, -50)
EspSection.Position = UDim2.new(0, 10, 0, 45)
EspSection.BackgroundTransparency = 1
EspSection.Visible = false
EspSection.Parent = ContentArea

local MiscSection = Instance.new("Frame")
MiscSection.Name = "MiscSection"
MiscSection.Size = UDim2.new(1, -20, 1, -50)
MiscSection.Position = UDim2.new(0, 10, 0, 45)
MiscSection.BackgroundTransparency = 1
MiscSection.Visible = false
MiscSection.Parent = ContentArea

-- Toggles Aim
createToggle(AimSection, "Aimbot", UDim2.new(0, 0, 0, 0), false, function(enabled)
    aimbotEnabled = enabled
    if enabled then startAimbot() else stopAimbot() end
end)

createToggle(AimSection, "Fov", UDim2.new(0, 0, 0, 30), false, function(enabled)
    fovVisible = enabled
    fovCircle.Visible = enabled
end)

createToggle(AimSection, "HeadSize", UDim2.new(0, 0, 0, 60), false, function(enabled)
    triggerbotEnabled = enabled
    if enabled then startTriggerbot() else stopTriggerbot() end
end)

createButtonControl(AimSection, "FOV Size", UDim2.new(0, 0, 0, 95), 10, 600, 80, 5, function(value)
    fovRadius = value
end)

createButtonControl(AimSection, "Smoothness", UDim2.new(0, 0, 0, 130), 1, 50, 15, 1, function(value)
    smoothness = value
end)

-- Toggles ESP
createToggle(EspSection, "ESP Chams", UDim2.new(0, 0, 0, 0), false, function(enabled)
    chamsEnabled = enabled
    if enabled and not espPlayerAddedConn then startESP() end
end)

createToggle(EspSection, "Esp Box", UDim2.new(0, 0, 0, 30), false, function(enabled)
    boxEspEnabled = enabled
    if enabled and not espPlayerAddedConn then startESP() end
end)

createToggle(EspSection, "Lines", UDim2.new(0, 0, 0, 60), false, function(enabled)
    linesEnabled = enabled
    if enabled and not espPlayerAddedConn then startESP() end
end)

createToggle(EspSection, "Name", UDim2.new(0, 0, 0, 90), false, function(enabled)
    nameEnabled = enabled
    if enabled and not espPlayerAddedConn then startESP() end
end)

createToggle(EspSection, "Distance", UDim2.new(0, 0, 0, 120), false, function(enabled)
    distanceEnabled = enabled
    if enabled and not espPlayerAddedConn then startESP() end
end)

-- Toggles Misc
createToggle(MiscSection, "Speed Hack", UDim2.new(0, 0, 0, 0), false, function(enabled)
    speedWalkEnabled = enabled
    if enabled then startSpeedWalk() else stopSpeedWalk() end
end)

createButtonControl(MiscSection, "Walk Speed", UDim2.new(0, 0, 0, 30), 16, 200, 16, 5, function(value)
    speedWalkValue = value
    updateSpeedWalk()
end)

createToggle(MiscSection, "LoopBring", UDim2.new(0, 0, 0, 65), false, function(enabled)
    loopBringEnabled = enabled
    if enabled then startLoopBring() else stopLoopBring() end
end)

createToggle(MiscSection, "No Clip", UDim2.new(0, 0, 0, 95), false, function(enabled)
    noclipEnabled = enabled
    if enabled then startNoclip() else stopNoclip() end
end)

createToggle(MiscSection, "Fly", UDim2.new(0, 0, 0, 125), false, function(enabled)
    flyEnabled = enabled
    if enabled then startFly() else stopFly() end
end)

createButtonControl(MiscSection, "Fly Speed", UDim2.new(0, 0, 0, 160), 10, 200, 50, 5, function(value)
    flySpeed = value
end)

-- Criar Tabs
local currentTab = nil
local function createTab(text, position, isActive, targetSection)
    local tab = Instance.new("TextButton")
    tab.Size = UDim2.new(0, 80, 1, 0)
    tab.Position = UDim2.new(0, position, 0, 0)
    tab.BackgroundTransparency = 1
    tab.Text = text
    tab.TextColor3 = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(153, 153, 153)
    tab.TextSize = 11
    tab.Font = Enum.Font.GothamSemibold
    tab.Parent = TabsContainer
    
    if isActive then
        local indicator = Instance.new("Frame")
        indicator.Name = "ActiveIndicator"
        indicator.Size = UDim2.new(1, 0, 0, 2)
        indicator.Position = UDim2.new(0, 0, 1, 0)
        indicator.BackgroundColor3 = Color3.fromRGB(255, 0, 255)
        indicator.BorderSizePixel = 0
        indicator.Parent = tab
        currentTab = tab
    end
    
    tab.MouseButton1Click:Connect(function()
        AimSection.Visible = false
        EspSection.Visible = false
        MiscSection.Visible = false
        targetSection.Visible = true
        
        for _, child in pairs(TabsContainer:GetChildren()) do
            if child:IsA("TextButton") then
                child.TextColor3 = Color3.fromRGB(153, 153, 153)
                if child:FindFirstChild("ActiveIndicator") then
                    child.ActiveIndicator:Destroy()
                end
            end
        end
        
        tab.TextColor3 = Color3.fromRGB(255, 255, 255)
        local indicator = Instance.new("Frame")
        indicator.Name = "ActiveIndicator"
        indicator.Size = UDim2.new(1, 0, 0, 2)
        indicator.Position = UDim2.new(0, 0, 1, 0)
        indicator.BackgroundColor3 = Color3.fromRGB(255, 0, 255)
        indicator.BorderSizePixel = 0
        indicator.Parent = tab
        currentTab = tab
    end)
end

createTab("Aim", 0, true, AimSection)
createTab("Esp", 85, false, EspSection)
createTab("Misc", 170, false, MiscSection)

-- Sistema de Minimizar
local isMinimized = false
local lastDotPosition = UDim2.new(0, 20, 0, 20)

local function minimizeUI()
    isMinimized = true
    MainContainer.Visible = false
    MinimizedDot.Visible = true
    MinimizedDot.Position = lastDotPosition
end

local function restoreUI()
    isMinimized = false
    MainContainer.Visible = true
    MinimizedDot.Visible = false
end

MinimizeButton.MouseButton1Click:Connect(minimizeUI)
MinimizedDot.MouseButton1Click:Connect(restoreUI)

-- Drag MainContainer
local dragging = false
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    MainContainer.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

MainContainer.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MainContainer.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MainContainer.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

-- Drag MinimizedDot
local dotDragging = false
local dotDragInput
local dotDragStart
local dotStartPos

local function updateDot(input)
    local delta = input.Position - dotDragStart
    local newPos = UDim2.new(0, dotStartPos.X.Offset + delta.X, 0, dotStartPos.Y.Offset + delta.Y)
    MinimizedDot.Position = newPos
    lastDotPosition = newPos
end

MinimizedDot.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dotDragging = true
        dotDragStart = input.Position
        dotStartPos = MinimizedDot.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dotDragging = false
                lastDotPosition = MinimizedDot.Position
            end
        end)
    end
end)

MinimizedDot.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dotDragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    elseif input == dotDragInput and dotDragging then
        updateDot(input)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
        dotDragging = false
    end
end)

-- Toggle UI com tecla K
local function toggleUI()
    if isMinimized then restoreUI() else minimizeUI() end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.K then toggleUI() end
end)

-- Notificação
local function createNotification()
    local notification = Instance.new("TextLabel")
    notification.Size = UDim2.new(0, 320, 0, 35)
    notification.Position = UDim2.new(0.5, -160, 0, 50)
    notification.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    notification.TextColor3 = Color3.fromRGB(255, 255, 255)
    notification.Text = "Pressione K para abrir/fechar"
    notification.TextSize = 12
    notification.Font = Enum.Font.GothamSemibold
    notification.BorderSizePixel = 0
    notification.Parent = ScreenGui
    
    local notificationCorner = Instance.new("UICorner")
    notificationCorner.CornerRadius = UDim.new(0, 8)
    notificationCorner.Parent = notification
    
    local notificationGradient = Instance.new("UIGradient")
    notificationGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 170))
    }
    notificationGradient.Rotation = 90
    notificationGradient.Parent = notification
    
    task.wait(5)
    if notification then notification:Destroy() end
end

createNotification()